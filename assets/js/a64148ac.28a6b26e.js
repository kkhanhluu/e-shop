"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[497],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>m});var i=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,i)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,i,n=function(e,t){if(null==e)return{};var r,i,n={},a=Object.keys(e);for(i=0;i<a.length;i++)r=a[i],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)r=a[i],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var c=i.createContext({}),l=function(e){var t=i.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},u=function(e){var t=l(e.components);return i.createElement(c.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var r=e.components,n=e.mdxType,a=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(r),h=n,m=p["".concat(c,".").concat(h)]||p[h]||d[h]||a;return r?i.createElement(m,o(o({ref:t},u),{},{components:r})):i.createElement(m,o({ref:t},u))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=r.length,o=new Array(a);o[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[p]="string"==typeof e?e:n,o[1]=s;for(var l=2;l<a;l++)o[l]=r[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,r)}h.displayName="MDXCreateElement"},6426:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var i=r(7462),n=(r(7294),r(3905));const a={title:"Architecture Overview",slug:"architecture-overview",sidebar_position:1},o="Overview",s={unversionedId:"explore/architecture/overview",id:"explore/architecture/overview",title:"Architecture Overview",description:"Eshop architecture",source:"@site/docs/explore/architecture/overview.md",sourceDirName:"explore/architecture",slug:"/explore/architecture/architecture-overview",permalink:"/e-shop/explore/architecture/architecture-overview",draft:!1,editUrl:"https://github.com/kkhanhluu/eshop/docs/explore/architecture/overview.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Architecture Overview",slug:"architecture-overview",sidebar_position:1},sidebar:"docs",previous:{title:"Getting started",permalink:"/e-shop/getting-started"},next:{title:"Code Flow",permalink:"/e-shop/explore/architecture/code-flow"}},c={},l=[{value:"Message queue",id:"message-queue",level:2},{value:"gRPC",id:"grpc",level:2},{value:"API Gateway",id:"api-gateway",level:2},{value:"Microservices",id:"microservices",level:2},{value:"Database",id:"database",level:2}],u={toc:l},p="wrapper";function d(e){let{components:t,...a}=e;return(0,n.kt)(p,(0,i.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"overview"},"Overview"),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Eshop architecture",src:r(4057).Z,width:"12472",height:"6479"})),(0,n.kt)("p",null,"The architecture proposes a microservice implementation with multiple microservices, each one having its own database. The microservices showcase different approaches, ranging from simple CRUD to CQRS patterns. The communication between the API gateway and services is established using gRPC, while an asynchronous, message-based communication is used between microservices."),(0,n.kt)("h2",{id:"message-queue"},"Message queue"),(0,n.kt)("p",null,"In this example, RabbitMQ was chosen as the message queue implementation, with one topic exchange and five different queues. Here's the RabbitMQ architecture:\n",(0,n.kt)("img",{alt:"Rabbitmq architecture",src:r(4959).Z,width:"639",height:"398"})),(0,n.kt)("h2",{id:"grpc"},"gRPC"),(0,n.kt)("p",null,"Most communications between microservices are decoupled using a message queue. However, the communication between the API Gateway and the internal services is implemented with gRPC. gRPC is a modern high-performance Remote Procedure Call framework that uses low bandwidth, making it a good candidate for internal microservices communication."),(0,n.kt)("h2",{id:"api-gateway"},"API Gateway"),(0,n.kt)("p",null,"The API gateway is currently implemented with tRPC, a library that helps build type-safe APIs by defining type-safe functions with TypeScript. The client application can directly call these functions on the inferred type-safe router. HTTP is still used under the hood to communicate between the client and server."),(0,n.kt)("p",null,"Currently, the API gateway only forwards requests to internal microservices and custom aggregators, giving the client a single endpoint to communicate with. For a more production-grade solution, the ",(0,n.kt)("a",{parentName:"p",href:"https://samnewman.io/patterns/architectural/bff/"},"Backens for Frontend (BFF)")," pattern should be considered, which publishes simplified APIs for different clients."),(0,n.kt)("h2",{id:"microservices"},"Microservices"),(0,n.kt)("p",null,"6 microservices are implemented with Java spring. The API gateway is implemented with Node.js. The reason to choose 2 different programming languages is to illustrate the advantage of microservices which allows services to be implemented, maintained easily, independently with different technologies."),(0,n.kt)("h2",{id:"database"},"Database"),(0,n.kt)("p",null,"In order to simplify development, one Postgres database server with multiple databases, one event store server, and one MongoDB server are all deployed to a single cluster. However, this is not a recommended approach for a production-grade solution."))}d.isMDXComponent=!0},4057:(e,t,r)=>{r.d(t,{Z:()=>i});const i=r.p+"assets/images/architecture-64ba597d4898075c06b04b8ee331a9d4.png"},4959:(e,t,r)=>{r.d(t,{Z:()=>i});const i=r.p+"assets/images/rabbitmq-architecture-f367e3cb6008f4a3065ce19f927e5f3f.png"}}]);